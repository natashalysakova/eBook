<div class="row">
    <div class="col-md-9 col-md-offset-3 myPanel">
        <div class="col-md-12">
            <h1>Приклади</h1>
            <hr/>
            <div class="panel panel-primary" id="coins">
                <div class="panel-heading">Задача про решту</div>
                <div class="panel-body text-justify">
                    Размен монет.
                    Сколькими различными способами можно выдать сдачу размером W рублей, если есть
                    монеты достоинством pi(i = 1, ..., N)? Для того чтобы сдачу всегда можно было
                    выдать, будем предполагать, что в наборе есть монета достоинством 1 рубль(p1 = 1).
                    Эта задача, так же как и задача о куче, решается только полным перебором
                    вариантов, число которых при больших N очень велико. Будем использовать
                    динамическое программирование, сохраняя в массиве решения всех задач меньшей
                    размерности (для меньших N и меньшего числа монет).

                    В матрице T значение T[i,w] будет обозначать количество вариантов сдачи размером w рублей (w
                    изменяется от 0 до W) при использовании первых i монет из набора. Очевидно, что при нулевой сдаче
                    есть только один вариант (не дать ни одной монеты), также и при наличии только одного типа монет
                    (напомним, что p1 = 1) есть тоже только один вариант. Поэтому нулевой столбец и первую строку
                    таблицы можно заполнить сразу единицами. Таким образом, мы определили простые базовые случаи, от
                    которых “отталкивается” рекуррентная формула.
                    Для примера мы будем рассматривать задачу для w = 10 и набора монет достоинством 1, 2, 5 и 10
                    рублей:
                    <div class="row text-center">
                        <div class="col-md-8">
                            <table class="table table-bordered">
                                <tr>
                                    <th>Pi\w</th>
                                    <th>0</th>
                                    <th>1</th>
                                    <th>2</th>
                                    <th>3</th>
                                    <th>4</th>
                                    <th>5</th>
                                    <th>6</th>
                                    <th>7</th>
                                    <th>8</th>
                                    <th>9</th>
                                    <th>10</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <td>1</td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <th>5</th>
                                    <td>1</td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <th>10</th>
                                    <td>1</td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </table>
                        </div>
                    </div>

                    Теперь рассмотрим общий случай. Заполнять nаблицу будем по строкам, слева направо. Для
                    вычисления
                    T[i,w]предположим, что мы добавляем в набор монету
                    достоинством pi.
                    Если сумма w меньше, чем pi , то количество вариантов не увеличивается, и T[i, w] = T[i -
                    1,w] .
                    Если сумма больше pi , то к этому значению нужно добавить количество вариантов с “участием”
                    новой
                    монеты. Если монета достоинством pi
                    использована, то нужно учесть все варианты “разложения” остатка w - pi на все доступные
                    монеты, то
                    есть T [ i , w ] = T [ i - 1, w ]+ T [ i , w - pi ] . В итоге получается рекуррентная
                    формула при
                    w < pi : T [ i , w ] = T [ i - 1, w ] при w pi : T[i,w] = T[i - 1,w]+ T[i,w - pi]
                    <div class="row">

                        <div class="col-md-8">
                            <table class="table table-bordered">
                                <tr>
                                    <th>Pi\w</th>
                                    <th>0</th>
                                    <th>1</th>
                                    <th>2</th>
                                    <th>3</th>
                                    <th>4</th>
                                    <th>5</th>
                                    <th>6</th>
                                    <th>7</th>
                                    <th>8</th>
                                    <th>9</th>
                                    <th>10</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>1</td>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>2</td>
                                    <td>2</td>
                                    <td>3</td>
                                    <td>3</td>
                                    <td>4</td>
                                    <td>4</td>
                                    <td>5</td>
                                    <td>5</td>
                                    <td>6</td>
                                </tr>
                                <tr>
                                    <th>5</th>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>2</td>
                                    <td>2</td>
                                    <td>3</td>
                                    <td>4</td>
                                    <td>5</td>
                                    <td>6</td>
                                    <td>7</td>
                                    <td>8</td>
                                    <td>10</td>
                                </tr>
                                <tr>
                                    <th>10</th>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>2</td>
                                    <td>2</td>
                                    <td>3</td>
                                    <td>4</td>
                                    <td>5</td>
                                    <td>6</td>
                                    <td>7</td>
                                    <td>8</td>
                                    <td>11</td>
                                </tr>
                            </table>

                        </div>
                    </div>

                    Использование методов динамического программирования позволяет ускорить решение за счет хр
                    анения
                    промежуточных результатов, однако требует дополнительного расхода памяти
                    <hr/>
                    <div class="col-md-12 text-center">
                        <a class="btn btn-primary" data-toggle="collapse" href="#video1" aria-expanded="false"
                           aria-controls="video1">
                            Відео-лекція
                        </a>

                        <div class="collapse" id="video1">
                            <div class="well">
                                <div class="embed-responsive embed-responsive-16by9">
                                    <iframe width="560" height="315"
                                            src="https://www.youtube.com/embed/b6_uoDsXZxs?list=PLUfHxBkkFMScK6mOOWp5s6LgbzmtfwmYQ"
                                            frameborder="0" allowfullscreen></iframe>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>

            <div class="panel panel-primary" id="square">
                <div class="panel-heading">Магічний квадрат</div>
                <div class="panel-body text-justify">
                    Подсчет числа маршрутов

                    Рассмотрим шахматную доску в левом верхнем углу которой находится король. Король может перемещаться
                    только вправо, вниз или по диагонали вправо-вниз на одну клетку. Необходимо определить количество
                    различных маршрутов короля, приводящих его в правый нижний угол.<br>

                    Сопоставим каждой клетке ее координаты (i,j), где i будет обозначать номер строки на доске, j —
                    номер столбца. Нумеровать строки будем сверху вниз, столбцы — слева направо, нумерация начинается с
                    0. Тогда начальное положение короля будет клетка (0,0).<br>

                    Обозначим через F(i,j) количество способов прийти из клетки (0,0) в клетку (i,j). В клетку (i,j)
                    можно прийти из трех клеток — слева из (i,j−1), сверху из (i−1,j) и по диагонали из (i−1,j−1).
                    Поэтому число маршрутов ведущих в клетку равно числу маршрутов из всех ее предшественников, а
                    именно:<br>

                    <code> F(i,j)=F(i,j−1)+F(i−1,j)+F(i−1,j−1)<br>
                    </code>
                    Отдельно нужно задать значения для граничных клеток, то есть когда i=0 или j=0. В результате
                    получится таблица заполненная следующим образом:<br>
                    <img src="img/2015-04-23_162247.png"><br>

                    Для заполнения этой таблицы и подсчета числа маршрутов можно использовать следующую программу, в
                    которой сначала создается двумерный список, затем заполняются крайние клетки (первый столбец и
                    первая строка), затем заполняются остальные элементы таблицы при помощи приведенного выше
                    рекуррентного соотношения. В данном примере n - число строк, m - число столбцов на доске.<br>

                    <code> F = [[0] * m for i in range(n)]<br>
                        for i in range(n):<br>
                        F[i][0] = 1<br>
                        for j in range(m):<br>
                        F[0][j] = 1<br>
                        for i in range(1, n):<br>
                        for j in range(1, m):<br>
                        F[i][j] = F[i][j - 1] + F[i - 1][j] + F[i - 1][j - 1]</code>

                    На этом примере можно составить общий план решения задачи методом динамического программирования.
                    Этот план можно использовать для решения любых задач при помощи динамического программирования:<br>
                    <ol>
                        <li>Записать то, что требуется найти в задаче, как целевую функцию от некоторого набора
                            аргументов
                            (числовых, строковых или еще каких-либо).
                        </li>
                        <li>Свести решение задачи для произвольного набора параметров к решению аналогичных подзадач для
                            других
                            наборов параметров (как правило, с меньшими значениями параметров). Если задача несложная,
                            то
                            полезно бывает выписать явное рекуррентное соотношение, задающее значение функции для
                            данного набора
                            параметров.
                        </li>
                        <li>Задать начальные значения функции, то есть те наборы аргументов, при которых задача
                            тривиальна и
                            можно явно указать значение функции.
                        </li>
                        <li>Создать массив (или другую структуру данных) для хранения значений функции. Как правило,
                            если
                            функция зависит от одного целочисленного параметра, то используется одномерный массив, для
                            функции
                            от двух целочисленных параметров — двумерный массив и т. д.
                        </li>
                        <li>Организовать заполнение массива с начальных значений, определяя очередной элемент массива
                            при помощи
                            выписанного на шаге 2 рекуррентного соотношения или алгоритма.
                        </li>
                    </ol>
                    Для заполнения первой строки и первого столбца таблицы мы использовали «специальную» формулу,
                    отличающуюся от общего случая. Но в некоторых задачах удобней бывает все значения вычислять по одной
                    и той же формуле, а для граничных значений функции ввести специальные «фиктивные» элементы. В данной
                    задаче тоже можно так поступить — введем специальную «каемочку» из одного фиктивного столбца слева и
                    одной фиктивной строки сверху таблицы.<br>

                    Для того, чтобы значения в остальной таблице вычислялись по общим формулам, во все клетки каемочки
                    нужно записать число 0, кроме клетки (0,0), в которую будет записано значение 1:<br>
                    <img src="img/2015-04-23_162257.png"><br>
                    Теперь во всех остальных клетках таблицы значения могут быть вычислены по общей формуле:
                    F(i,j)=F(i,j−1)+F(i−1,j)+F(i−1,j−1), а программа может выглядеть так:

                    <code> F = [[0] * (m + 1) for i in range(n + 1)]<br>

                        F[0][0] = 1
                        <br>
                        for i in range(1, n + 1):<br>

                        for j in range(1, m + 1):<br>

                        F[i][j] = F[i][j - 1] + F[i - 1][j] + F[i - 1][j — 1]</code>


                    <hr/>
                    <div class="col-md-12 text-center">
                        <a class="btn btn-primary" data-toggle="collapse" href="#video3"
                           aria-expanded="false"
                           aria-controls="video3">
                            Відео-лекція
                        </a>

                        <div class="collapse" id="video3">
                            <div class="well">
                                <div class="embed-responsive embed-responsive-16by9">
                                    <iframe width="560" height="315"
                                            src="https://www.youtube.com/embed/59Q9q5-rMuE?list=PLUfHxBkkFMScK6mOOWp5s6LgbzmtfwmYQ"
                                            frameborder="0" allowfullscreen></iframe>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="panel panel-primary" id="line">
                <div class="panel-heading">Максимальна підпослідовність</div>
                <div class="panel-body text-justify">
                    Бітонічна підпослідовність

                    <p>Послідовність чисел b1, b2, ..., bm називається бітонічною, якщо існує таке число j (1< j < m),
                        що виконуються нерівності b1 < b2 < ... < bj > bj+1 > ... > bm. Відмітимо, що у відповідності з
                        цим визначенням, бітонічна послідовність повинна містити хоча б три елементи.</p>

                    <p> Нехай задано деяку послідовність чисел a1, a2, ..., an. Її підпослідовністю називається
                        послідовність наступного виду:
                        ai1, ai2, ..., aik
                    </p>

                    <p> При цьому для чисел i1, ..., ik повинні виконуватись нерівності 1 ≤ i1 ≤ i2 ≤ ... ≤ ik ≤ n.
                    </p>

                    <p> Задача полягає у тому, щоб написати програму, яка знайде бітонічну підпослідовність заданої
                        послідовності, для якої максимальна сума цифр чисел, що входять до неї. При цьому припускається,
                        що числа записано у десятковій системі числення.
                    </p>
                    <hr/>
                    <div class="col-md-12 text-center">
                        <a class="btn btn-primary" data-toggle="collapse" href="#video4"
                           aria-expanded="false"
                           aria-controls="video4">
                            Відео-лекція
                        </a>

                        <div class="collapse" id="video4">
                            <div class="well">

                                <div class="embed-responsive embed-responsive-16by9">
                                    <iframe width="560" height="315"
                                            src="https://www.youtube.com/embed/HKBAs2ET9ic?list=PLUfHxBkkFMScK6mOOWp5s6LgbzmtfwmYQ"
                                            frameborder="0" allowfullscreen></iframe>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="panel panel-primary" id="way">
                <div class="panel-heading">Пошук шляху у графі</div>
                <div class="panel-body text-justify">
                    <p>Алгоритм Беллмана—Форда - алгоритм пошуку найкоротшого шляху в зваженому графі. Знаходить
                        найкоротші шляхи від однієї вершини графа до всіх інших. На відміну від алгоритму Дейкстри,
                        алгоритм Беллмана—Форда допускає ребра з негативною вагою. Запропоновано незалежно Річардом
                        Беллманом і Лестером Фордом.</p>

                    <p>Історія

                        Алгоритм носить ім'я двох американських вчених: Річарда Беллмана (Richard Bellman) і Лестера
                        Форда (Lester Ford). Форд фактично винайшов цей алгоритм в 1956 році при вивченні іншої
                        математичної задачі, підзадача якої звелася до пошуку найкоротшого шляху в графі, і Форд зробив
                        начерк остаточного вирішення завдання цього алгоритма. Беллман в 1958 р. опублікував статтю,
                        присвячену конкретно завданню знаходження найкоротшого шляху, і в цій статті він чітко
                        сформулював алгоритм у тому вигляді, в якому він відомий нам зараз.</p>

                    <p>Алгоритм маршрутизації RIP (алгоритм Беллмана - Форда) був вперше розроблений в 1969 році, як
                        основний для мережі ARPANET.</p>
                    Формулювання задачі

                    <p>Дано орієнтований або неорієнтований граф G(V, E) з ваговою функцією w:E\to \mathbb{R}. Вагою
                        w(p) шляху p=\langle v_0, v_1, \dots, v_k \rangle назвемо суму ваг ребер, що входять в цей шлях:
                        w(p)=\sum_{i=1}^k w(v_{i-1}, v_i).</p>

                    <p>Вхідними даними для алгоритму є граф G, вагова функція w, та стартова вершина s. Потрібно знайти
                        найкоротші шляхи від вершини s до всіх вершин графа. Алгоритм Беллмана-Форда повертає логічне
                        значення, яке вказує на те, чи міститься в графі цикл з негативною вагою, досяжний з витоку.
                        Якщо такий цикл існує у графі G, алгоритм повідомляє, що найкоротших шляхів не існує. Якщо ж
                        таких циклів немає, алгоритм видає найкоротші шляхи і їх вагу.</p>

                    <p>Сам алгоритм Форда-Беллмана представляє з себе кілька фаз. На кожній фазі проглядаються всі ребра
                        графа, і алгоритм намагається справити релаксацію (relax, ослаблення) уздовж кожного ребра (u,v)
                        ваги w(u,v). Релаксація вздовж ребра — це спроба поліпшити значення v.d значенням v.u+w(u,v) .
                        Фактично це означає, що ми намагаємося поліпшити значення для вершини v, користуючись ребром
                        (u,v) і поточним значенням для вершини u . Стверджується, що достатньо |G.V|-1 фази алгоритму,
                        щоб коректно порахувати довжини всіх найкоротших шляхів у графі (цикли негативної ваги
                        відсутні). Для недосяжних вершин відстань v.d залишиться нескінченністю.</p>
                    <code> Псевдокод
                        // Ініціалізація<br>
                        для кожної вершини v \in G.V<br>
                        v.d = \infty<br>
                        v.\pi = NIL<br>
                        s.d = 0<br>
                        // Основна частина<br>
                        для i = 1 до |G.V| - 1<br>
                        для кожного ребра (u,v) \i G.E<br>
                        якщо v.d > u.d + w(u, v)<br>
                        v.d = u.d + w(u, v)<br>
                        w.\pi = u // зберігаємо попередню вершину<br>
                        // Перевірка на наявність циклів з від'ємною вагою<br>
                        для кожного ребра (u,v) \in G.E<br>
                        якщо v.d > u.d + w(u, v)<br>
                        повернути ХИБА<br>
                        повернути ІСТИНА
                    </code>

                    <p>
                        Оцінка складності

                        Якщо граф заданий списком ребер: ініціалізація потребує O(V) часу, кожен з |V| - 1 проходів
                        потребує O(E) часу, прохід по усім ребрам для перевірки наявності негативного циклу займає O(E)
                        часу. Отже алгоритм працює за O(VE) часу.
                    </p>

                    <p>Якщо граф заданий матрицею суміжності, то алгоритм буде виконуватись за O(E^3) часу.</p>

                    <hr/>
                    <div class="col-md-12 text-center">
                        <a class="btn btn-primary" data-toggle="collapse" href="#video5"
                           aria-expanded="false"
                           aria-controls="video5">
                            Відео-лекція
                        </a>

                        <div class="collapse" id="video5">
                            <div class="well">
                                <div class="embed-responsive embed-responsive-16by9">
                                    <iframe width="560" height="315"
                                            src="https://www.youtube.com/embed/0gYMePv5JYU?list=PLUfHxBkkFMScK6mOOWp5s6LgbzmtfwmYQ"
                                            frameborder="0" allowfullscreen></iframe>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="panel panel-primary" id="car">
                <div class="panel-heading">Задача амортизації</div>
                <div class="panel-body text-justify">
                    Задача амортизації виглядає наступним чином: мається якесь майно. На його утримання власник сплачує
                    амортизаційні відчислення. С кожним роком сума, за яку можна продати це майно зменшується, бо майно
                    стає старішим. Питання в задачі стає таке: в який рік найвигідніше продати це майно, щоб витратити
                    на покупку нового та утримання старого найменше коштів. Нехай, R- ціна нового майна, C_i- кількість
                    амортизаційних відчислень за майно віком i, S_i- ціна продажу майна віком i без купівлі нового, t_i-
                    ціна продажу майна віком i за умови купівлі нового, Z_1- початковий вік майна, n- кількість років
                    для прийняття рішення.<br>
                    Тоді цільова функція задачі буде дорівнювати:<br>
                    F_i (Z_1 )=min⁡〖(-t_z+R+C_1+F_(i+1) (1)),(C_(z+1)+F_(i+1) (Z+1))〗<br>
                    При цьому F_i (Z_n )= -S_i<br>
                    Таким чином, можна отримати відповідь на питання коли краще продати майно, та вигідніше купити нове.
                    <hr/>
                    <div class="col-md-12 text-center">
                        <a class="btn btn-primary" data-toggle="collapse" href="#video6"
                           aria-expanded="false"
                           aria-controls="video6">
                            Відео-лекція
                        </a>

                        <div class="collapse" id="video6">
                            <div class="well">
                                <div class="embed-responsive embed-responsive-16by9">
                                    <iframe width="560" height="315"
                                            src="https://www.youtube.com/embed/yiJM7tcGnFs?list=PLUfHxBkkFMScK6mOOWp5s6LgbzmtfwmYQ"
                                            frameborder="0" allowfullscreen></iframe>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
            <hr/>
            <div class="row">
                <div class="col-md-6 text-center">
                    <div class="btn btn-success btn-lg" onclick="ShowPage('theory');">
                        Перейти до теорії
                    </div>
                </div>
                <div class="col-md-6 text-center">
                    <div class="btn btn-success btn-lg" onclick="ShowPage('test')">Перейти
                        до тестування
                    </div>
                </div>

            </div>
        </div>
    </div>

    <div class="col-md-2" data-spy="affix" data-offset-top="0" data-offset-bottom="0"
         id="menu">
        <div class="panel panel-primary">
            <div class="panel-heading">Зміст</div>
            <ul class="list-group">
                <li class="list-group-item"><a href="#coins">Задача про решту</a></li>
                <li class="list-group-item"><a href="#square">Магічний квадрат</a></li>
                <li class="list-group-item"><a href="#line">Максимальна підпослідовність</a>
                </li>
                <li class="list-group-item"><a href="#way">Пошук шляху у графі</a></li>
                <li class="list-group-item"><a href="#car">Задача амортизації</a></li>
            </ul>
        </div>
    </div>
</div>
